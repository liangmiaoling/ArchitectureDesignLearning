在具体的实践过程中，为了更快、更好地设计出优秀的架构，除了掌握这些基础知识外，还需要掌握业界已经成熟的各种架构模式，大部分情况下，我们做架构设计主要都是基于已有的成熟模式，结合业务和团队的具体情况，进行一定的优化或者调整；即使少部分情况我们需要进行较大的创新，前提也是需要对已有的各种架构模式和技术非常熟悉。

高性能架构模式
高可用架构模式
可扩展架构模式

高性能数据库集群的
第一种方式是：“读写分离”，其本质是将访问压力分散到集群中的多个节点，但是没有分散存储压力；
第二种方式是“分库分表”，既可以分散访问压力，又可以分散存储压力。

一、高性能数据库集群：读写分离 

读写分离原理
读写分离的基本原理是将数据库读写操作分散到不同的节点上。

读写分离的基本实现是：
1、数据库服务器搭建主从集群，一主一从、一主多从都可以。
2、数据库主机负责读写操作，从机只负责读操作。
3、数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。
4、业务服务器将写操作发给数据库主机，将读操作发给数据库从机。

需要注意的是这里用的“主从集群”，而不是“主备集群”。“从机”的“从”可以理解为“仆从”，仆从是要帮主人干活的，“从机”是需要提供读数据的功能的，而“备机”一般被认为仅仅提供备份功能，不提供访问功能。所以使用“主从”还是主备，是要看场景的，这两个词并不是完全等同的。

引入设计复杂度：主从复制延迟和分配机制。

1、复制延迟

主从复制延迟带来一个问题：如果业务服务器将数据写入到数据库主服务器后立刻（1秒内）进行读取，此时读操作访问的是从机，主机还没有将数据复制过去，到从机读取数据数读不到最新数据的，业务上就可能出现问题。
（1）解决主从复制延迟有集中常见的方法：
        1）写操作后的读操作指定发给数据库主服务器
        2）读从机失败后再读一次主机
        3）关键业务读写操作全部指向主机，非关键业务采用读写分离

2、分配机制

将读写操作分开来，然后访问不同的数据库服务器，一般有两种方式：程序代码封装和中间件封装。
（1）程序代码封装
程序封装指在代码中抽象一个数据访问层（所以有的文章也称这种方式为“中间层封装”），实现读写操作分离和数据库服务器连接的管理。
    1）实现简单，而且可以根据业务做较多定制化的功能。
    2）每个编程语言都需要自己实现一次，无法通用，如果一个业务包含多个编程语言写的多个子系统，则重复开发的工作量比较大。
    3）故障情况下，如果主从发生切换，则可能需要所有系统都修改配置并重启。
目前开源的实现方案中淘宝TDDL比较有名。他是一个通用数据访问层，所有功能封装在jar包中提供给业务代码调用。其基本原理是一个基于集中式配置的JDBC DataSource实现，具有主备、读写分离、动态数据库配置等功能。

（2）中间件封装
中间件封装指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。
数据库中间件的方式具备的特点：
    1）能够支持多种编程语言，因为数据库中间件对业务服务器提供的是标准SQL接口。
    2）数据库中间件要支持完整的SQL语法和数据库服务器的协议，实现比较复杂，细节特别多，很容易出现BUG，需要较长的时间才能稳定。
    3）数据库中间件自己不执行真正的读写操作，但所有的数据库操作请求都要经过中间件，中间件的性能要求也很高。
    4）数据库主从切换对业务服务器无感知，数据库中间件可以探测数据库服务器的主从状态。

由于数据库中间件的复杂度要比程序代码封装高出一个数量级，一般情况下建议采用横须语言封装的方式，或者使用成熟的开源数据库中间件。

目前的开源数据库中间件方案中，MySQL官方是提供了MySQL proxy，但MySQL proxy一直没有正式GA，现在MySQL官方推荐MySQL router。其主要功能有读写分离、故障自动切换、负载均衡、连接池等。

奇虎360公司也开源了自己的数据库中间件Atlas,其是基于MySQL proxy实现的。

二、高性能数据库集群：分库分表

当数据量达到千万甚至上亿条的时候，单台数据库服务器的存储能力称为系统的瓶颈，主要体现在这几个方面：
（1）数据量太大，读写的性能会下降，即使有索引，索引也会变得很大，性能同样会下降。
（2）数据文件会变得很大，数据库备份和恢复需要耗费很长时间。
（3）数据文件越大，极端情况下丢失数据的风险越高。
基于上述原因，单个数据库服务器存储的数据量不能太大，需要控制在一定的范围内。为了满足业务数据存储的需求，就需要将存储分散到多台数据库服务器上。

常见的分散存储的方法“分库分表”，其中包括“分库”和“分表”两大类。
1、业务分库
业务分库指的是按照业务模块将数据分散到不同的数据库服务器。
虽然业务分库能够分散存储和访问压力，但同时也带来了新的问题，接下来我进行详细分析：
（1）join操作问题
    业务分库后，原本在同一个数据库中的表分散到不同数据库中，导致无法使用SQL的join查询。
（2）事务问题
原本在同一个数据库中不同的表可以在同一个事务中修改，业务分库后，表分散到不同的数据库中，无法通过事务统一修改。

（3）成本问题
业务分库同时也带来了成本的代价。初创业务存在很大的不确定性，业务不一定能发展起来，业务开始。
一般来说，单台数据库服务器能够支撑10万用户量量级的业务，初创业务从0发展到10万级用户，并不是想象得那么快。
最好在业务开始设计时就考虑业务分库。

2、分表
将不同业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但如果业务继续发展，同一业务的单表数据也会达到单台数据库服务器的处理瓶颈。

单表拆分有两种方式：垂直分表和水平分表。
理解垂直拆分和水平拆分的区别：
（1）从上往上就是垂直切分，对应到表的切分就是表记录数相同但包含不同的列。
（2）从左往右切就是水平切分，对应到表的切分就是表的列相同但包含不同的行的数据。

单表进行切分后，是否要将切分后的多个表分散在不同的数据库服务器中，可以根据实际的切分效果来确定，并不强制要求单表切分为多表后一定要分散到不同数据库中。

分表能够有效地分散存储压力和带来性能提升，但分库一样，也会引入各种复杂性。
（1）垂直分表
垂直分表适合将表中某些不常用且占了大量空间的列拆分出去。
（2）水平分表
水平分表适合表行数特别大的表，有的公司要求单表行数超过5000万就进行分表，这个数字可以作为参考，但并不是绝对标准，关键还是看表的访问性能。

水平分表相比垂直分表，会引入更多的复杂性，主要表现在下面几个方面：

（1）路由
水平分表后，某条数据具体属于哪个切分后的子表，需要增加路由算法进行计算，这个算法会引入一定的复杂性。

常见的路由算法有：
1）范围路由
    选取有序的数据列作为路由的条件，不同分段分散到不同的数据库表中。
    范围路由设计的复杂点：主要体现在分段大小的选取上，分段太小会导致切分后子表数量过多，增加维护复杂度；分段太大可能会导致单表依然存在性能问题，一般建议分段大小在100万至2000万之间，具体需要根据业务选取合适的分段大小。

    范围路由的优点：可以随着数据的增加平滑地扩充新的表。
                      缺点：是分布不均匀。
2）hash路由
    选取某个列（或者某几列组合也可以）的值进行hash运算，然后根据hash结果分散到不同的数据库表中。
hash路由设计的复杂点：主要体现在初始表数量的选取上，表数量太多维护比较麻烦，标数量太少又可能导致单表性能存在问题。而用了hash路由后，增加字表数量非常麻烦的，所有数据都有重分布。
优点：表分布比较均匀
缺点：扩充新表很麻烦，所有数据都要重分布。

3）配置路由
配置路由就是路由表，用一张独立的表来记录路由信息。
优点：配置路由设置简单，使用起来非常灵活，尤其是在扩充表的时候，只需要迁移指定的数据，然后修改路由表就可以了。
缺点：必须多查询一次，会影响整体性能；而且路由表本身如果太大，性能同样可能成为瓶颈，如果我们再次将路由表分库分表，则面临一个死循环的路由算法选择问题。

*     join操作
    水平分表后，数据分散在多个表中，如果需要与其他表进行join查询，需要在业务代码或者数据库中间件中进行多次join查询，然后将结果合并。

*     count()操作
    水平分表后，虽然物理上数据分散到多个表中，但某些业务逻辑上海市会讲这些表单做一个表来处理。
    常见的处理方式：
        count()相加：具体做法是在业务代码或者数据库中间件对每个表进行count()操作，然后将结果相加。
        记录数表：具体做法是建一张表，加入表名为“记录数表”，包含table_name、row_count两个字段，每次插入或者删除子表数据成功后，都更新“记录数表”。
    记录数表这个方式获取记录数的性能要大大优于count()相加的方式，因为只需要一次简单查询就可以获取数据。
        记录数表缺点：复杂度增加不少，对于自表的操作要同步才做“记录数表”，如果一个业务逻辑遗漏了，数据就会不一致；且针对“记录数表”的操作和针对子表的操作无法放在同一事物中进行处理，异常的情况下出现操作子表成功了而操作记录数表失败，同样会导致数据不一致。同时也增加了数据库的写压力，因为每次针对子表的insert和delete操作都要update记录数表，所以对于一些不要求记录数试试保持精确的业务，也可以通过后台定时更行记录数据表。

* orderby 操作
水平分表后，数据分散到多个子表中，排序操作无法在数据库中完成，只能由业务代码或者数据库中间件分别查询每个子表中的数据，然后汇总进行排序。

3、实现方法

程序代码封装和中间件封装。

补充：
1、硬件优化
2、先做数据库服务的调优操作
3、引入缓存技术，例如Redis，减少数据库压力
4、程序与数据库优化，重构。例如根据业务逻辑对程序逻辑优化，减少不必要的查询
5、在这些操作都不能大幅度优化性能的情况下，不能满足将来的发展，在考虑分库分表，也要有预估性。
    
三、高性能NoSQL
1、关系数据库存在如下缺点：
（1）关系数据库的行记录，无法存储数据结构。
（2）关系数据库的schema扩展很不方便。
关系数据库的表结构schema是强约束，操作不存在的列会报错，业务变化时扩充列也比较麻烦，需要DDL语句修改，而且修改时可能会长时间锁表。
（3）关系数据库在大数据场景下I/O较高。
（4）关系数据库的全文搜索功能比较弱。

针对上述问题，分别诞生不同的NoSQL解决方案。NoSQL解决方案带来的优势，本质上是牺牲ACID中的某个或者某几个特性，因此不能盲目地迷信NoSQL是银弹，而应该将NoSQL作为SQL的一个有力补充。

常见的NoSQL解决方案分为4类：
（1）K-V存储：解决关系数据库无法存储数据结构的问题，以Redis为代表。
（2）文档数据库：解决关系数据库强schema约束的问题，以MongoDB为代表。
（3）列式数据库：解决关系数据库大数据场景下的I/O问题，以HBase为例。
（4）全文搜索引擎：解决关系数据库的全文搜索性能问题，以Elasticsearch为代表。


K-V 存储
K-V 存储的全称是 Key-Value 存储，其中 Key 是数据的标识，和关系数据库中的主键含义一样，Value 就是具体的数据。

Redis 是 K-V 存储的典型代表，它是一款开源（基于 BSD 许可）的高性能 K-V 缓存和存储系统。Redis 的 Value 是具体的数据结构，包括 string、hash、list、set、sorted set、bitmap 和 hyperloglog，所以常常被称为数据结构服务器。

以 List 数据结构为例，Redis 提供了下面这些典型的操作（更多请参考链接：http://redis.cn/commands.html#list）：
LPOP key 从队列的左边出队一个元素。

LINDEX key index 获取一个元素，通过其索引列表。

LLEN key 获得队列（List）的长度。

RPOP key 从队列的右边出队一个元素。

以上这些功能，如果用关系数据库来实现，就会变得很复杂。例如，LPOP 操作是移除并返回 key 对应的 list 的第一个元素。如果用关系数据库来存储，为了达到同样目的，需要进行下面的操作：

每条数据除了数据编号（例如，行 ID），还要有位置编号，否则没有办法判断哪条数据是第一条。注意这里不能用行 ID 作为位置编号，因为我们会往列表头部插入数据。

查询出第一条数据。

删除第一条数据。

更新从第二条开始的所有数据的位置编号。
可以看出关系数据库的实现很麻烦，而且需要进行多次 SQL 操作，性能很低。

Redis 的缺点主要体现在并不支持完整的 ACID 事务，Redis 虽然提供事务功能，但 Redis 的事务和关系数据库的事务不可同日而语，Redis 的事务只能保证隔离性和一致性（I 和 C），无法保证原子性和持久性（A 和 D）。

虽然 Redis 并没有严格遵循 ACID 原则，但实际上大部分业务也不需要严格遵循 ACID 原则。以上面的微博关注操作为例，即使系统没有将 A 加入 B 的粉丝列表，其实业务影响也非常小，因此我们在设计方案时，需要根据业务特性和要求来确定是否可以用 Redis，而不能因为 Redis 不遵循 ACID 原则就直接放弃。

文档数据库
为了解决关系数据库 schema 带来的问题，文档数据库应运而生。文档数据库最大的特点就是 no-schema，可以存储和读取任意的数据。目前绝大部分文档数据库存储的数据格式是 JSON（或者 BSON），因为 JSON 数据是自描述的，无须在使用前定义字段，读取一个 JSON 中不存在的字段也不会导致 SQL 那样的语法错误。
文档数据库的 no-schema 特性，给业务开发带来了几个明显的优势。

1. 新增字段简单

业务上增加新的字段，无须再像关系数据库一样要先执行 DDL 语句修改表结构，程序代码直接读写即可。

2. 历史数据不会出错

对于历史数据，即使没有新增的字段，也不会导致错误，只会返回空值，此时代码进行兼容处理即可。

3. 可以很容易存储复杂数据

JSON 是一种强大的描述语言，能够描述复杂的数据结构。例如，我们设计一个用户管理系统，用户的信息有 ID、姓名、性别、爱好、邮箱、地址、学历信息。其中爱好是列表（因为可以有多个爱好）；地址是一个结构，包括省市区楼盘地址；学历包括学校、专业、入学毕业年份信息等。如果我们用关系数据库来存储，需要设计多张表，包括基本信息（列：ID、姓名、性别、邮箱）、爱好（列：ID、爱好）、地址（列：省、市、区、详细地址）、学历（列：入学时间、毕业时间、学校名称、专业），而使用文档数据库，一个 JSON 就可以全部描述。

 {                    
    "id": 10000, 
    "name": "James", 
    "sex": "male", 
    "hobbies": [  
        "football", 
        "playing", 
        "singing"
    ], 
    "email": "user@google.com", 
    "address": {  
        "province": "GuangDong", 
        "city": "GuangZhou", 
        "district": "Tianhe", 
        "detail": "PingYun Road 163"
    }, 
    "education": [  
        {  
            "begin": "2000-09-01", 
            "end": "2004-07-01", 
            "school": "UESTC", 
            "major": "Computer Science & Technology"
        },       {  
            "begin": "2004-09-01", 
            "end": "2007-07-01", 
            "school": "SCUT", 
            "major": "Computer Science & Technology"
        }
    ]
 }
通过这个样例我们看到，使用 JSON 来描述数据，比使用关系型数据库表来描述数据方便和容易得多，而且更加容易理解。

文档数据库的这个特点，特别适合电商和游戏这类的业务场景。以电商为例，不同商品的属性差异很大。例如，冰箱的属性和笔记本电脑的属性差异非常大，如下图所示。



即使是同类商品也有不同的属性。例如，LCD 和 LED 显示器，两者有不同的参数指标。这种业务场景如果使用关系数据库来存储数据，就会很麻烦，而使用文档数据库，会简单、方便许多，扩展新的属性也更加容易。

文档数据库 no-schema 的特性带来的这些优势也是有代价的，最主要的代价就是不支持事务。例如，使用 MongoDB 来存储商品库存，系统创建订单的时候首先需要减扣库存，然后再创建订单。这是一个事务操作，用关系数据库来实现就很简单，但如果用 MongoDB 来实现，就无法做到事务性。异常情况下可能出现库存被扣减了，但订单没有创建的情况。因此某些对事务要求严格的业务场景是不能使用文档数据库的。

文档数据库另外一个缺点就是无法实现关系数据库的 join 操作。例如，我们有一个用户信息表和一个订单表，订单表中有买家用户 id。如果要查询“购买了苹果笔记本用户中的女性用户”，用关系数据库来实现，一个简单的 join 操作就搞定了；而用文档数据库是无法进行 join 查询的，需要查两次：一次查询订单表中购买了苹果笔记本的用户，然后再查询这些用户哪些是女性用户。

列式数据库
顾名思义，列式数据库就是按照列来存储数据的数据库，与之对应的传统关系数据库被称为“行式数据库”，因为关系数据库是按照行来存储数据的。 

关系数据库按照行式来存储数据，主要有以下几个优势：

业务同时读取多个列时效率高，因为这些列都是按行存储在一起的，一次磁盘操作就能够把一行数据中的各个列都读取到内存中。

能够一次性完成对一行中的多个列的写操作，保证了针对行数据写操作的原子性和一致性；否则如果采用列存储，可能会出现某次写操作，有的列成功了，有的列失败了，导致数据不一致。

我们可以看到，行式存储的优势是在特定的业务场景下才能体现，如果不存在这样的业务场景，那么行式存储的优势也将不复存在，甚至成为劣势，典型的场景就是海量数据进行统计。例如，计算某个城市体重超重的人员数据，实际上只需要读取每个人的体重这一列并进行统计即可，而行式存储即使最终只使用一列，也会将所有行数据都读取出来。如果单行用户信息有 1KB，其中体重只有 4 个字节，行式存储还是会将整行 1KB 数据全部读取到内存中，这是明显的浪费。而如果采用列式存储，每个用户只需要读取 4 字节的体重数据即可，I/O 将大大减少。
除了节省 I/O，列式存储还具备更高的存储压缩比，能够节省更多的存储空间。普通的行式数据库一般压缩率在 3:1 到 5:1 左右，而列式数据库的压缩率一般在 8:1 到 30:1 左右，因为单个列的数据相似度相比行来说更高，能够达到更高的压缩率。

同样，如果场景发生变化，列式存储的优势又会变成劣势。典型的场景是需要频繁地更新多个列。因为列式存储将不同列存储在磁盘上不连续的空间，导致更新多个列时磁盘是随机写操作；而行式存储时同一行多个列都存储在连续的空间，一次磁盘写操作就可以完成，列式存储的随机写效率要远远低于行式存储的写效率。此外，列式存储高压缩率在更新场景下也会成为劣势，因为更新时需要将存储数据解压后更新，然后再压缩，最后写入磁盘。

基于上述列式存储的优缺点，一般将列式存储应用在离线的大数据分析和统计场景中，因为这种场景主要是针对部分列单列进行操作，且数据写入后就无须再更新删除。

全文搜索引擎
传统的关系型数据库通过索引来达到快速查询的目的，但是在全文搜索的业务场景下，索引也无能为力，主要体现在：
全文搜索的条件可以随意排列组合，如果通过索引来满足，则索引的数量会非常多。

全文搜索的模糊匹配方式，索引无法满足，只能用 like 查询，而 like 查询是整表扫描，效率非常低。

我举一个具体的例子来看看关系型数据库为何无法满足全文搜索的要求。假设我们做一个婚恋网站，其主要目的是帮助程序员找朋友，但模式与传统婚恋网站不同，是“程序员发布自己的信息，用户来搜索程序员”。程序员的信息表设计如下：

ID 姓名 性别 地点 单位 爱好 语言 自我介绍
1 多隆 男 北京 猫厂 写代码、旅游、马拉松 Java、C++、PHP 技术专家，简单，为人热情 
2 如花 女 上海 鹅厂 旅游、美食、唱歌 PHP、Java 美女如花，风华绝代，貌美如花 
3 小宝 男 广州 熊厂 泡吧、踢球 Python、Go、C 我是一匹来自北方的狼 
我们来看一下这个简单业务的搜索场景：

美女 1：听说 PHP 是世界上最好的语言，那么 PHP 的程序员肯定是钱最多的，而且我妈一定要我找一个上海的。
美女 1 的搜索条件是“性别 + PHP + 上海”，其中“PHP”要用模糊匹配查询“语言”列，“上海”要查询“地点”列，如果用索引支撑，则需要建立“地点”这个索引。

美女 2：我好崇拜这些技术哥哥啊，要是能找一个鹅厂技术哥哥陪我旅游就更好了。
美女 2 的搜索条件是“性别 + 鹅厂 + 旅游”，其中“旅游”要用模糊匹配查询“爱好”列，“鹅厂”需要查询“单位”列，如果要用索引支撑，则需要建立“单位”索引。

美女 3：我是一个“女程序员”，想在北京找一个猫厂的 Java 技术专家。
美女 3 的搜索条件是“性别 + 猫厂 + 北京 + Java + 技术专家”，其中“猫厂 + 北京”可以通过索引来查询，但“Java”“技术专家”都只能通过模糊匹配来查询。

帅哥 4：程序员妹子有没有漂亮的呢？试试看看。
帅哥 4 的搜索条件是“性别 + 美丽 + 美女”，只能通过模糊匹配搜索“自我介绍”列。

以上只是简单举个例子，实际上搜索条件是无法列举完全的，各种排列组合非常多，通过这个简单的样例我们就可以看出关系数据库在支撑全文搜索时的不足。

1. 全文搜索基本原理

全文搜索引擎的技术原理被称为“倒排索引”（Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，其基本原理是建立单词到文档的索引。之所以被称为“倒排”索引，是和“正排“索引相对的，“正排索引”的基本原理是建立文档到单词的索引。我们通过一个简单的样例来说明这两种索引的差异。

假设我们有一个技术文章的网站，里面收集了各种技术文章，用户可以在网站浏览或者搜索文章。

正排索引示例：

文章 ID 文章名称 文章内容
1 敏捷架构设计原则 省略具体内容，文档内容包含：架构、设计、架构师等单词
2 Java 编程必知必会 省略具体内容，文档内容包含：Java、编程、面向对象、类、架构、设计等单词
3 面向对象葵花宝典是什么 省略具体内容，文档内容包含：设计、模式、对象、类、Java 等单词
（注：文章内容仅为示范，文章内容实际上存储的是几千字的内容。）

正排索引适用于根据文档名称来查询文档内容。例如，用户在网站上单击了“面向对象葵花宝典是什么”，网站根据文章标题查询文章的内容展示给用户。

倒排索引示例：

单词 文档 ID 列表
架构 1，2
设计 1，2，3
Java 2，3
（注：表格仅为示范，不是完整的倒排索引表格，实际上的倒排索引有成千上万行，因为每个单词就是一个索引。）

倒排索引适用于根据关键词来查询文档内容。例如，用户只是想看“设计”相关的文章，网站需要将文章内容中包含“设计”一词的文章都搜索出来展示给用户。

2. 全文搜索的使用方式

全文搜索引擎的索引对象是单词和文档，而关系数据库的索引对象是键和行，两者的术语差异很大，不能简单地等同起来。因此，为了让全文搜索引擎支持关系型数据的全文搜索，需要做一些转换操作，即将关系型数据转换为文档数据。

目前常用的转换方式是将关系型数据按照对象的形式转换为 JSON 文档，然后将 JSON 文档输入全文搜索引擎进行索引。我同样以程序员的基本信息表为例，看看如何转换。

将前面样例中的程序员表格转换为 JSON 文档，可以得到 3 个程序员信息相关的文档，我以程序员 1 为例：

 {
  "id": 1,
  " 姓名 ": " 多隆 ",
  " 性别 ": " 男 ",
  " 地点 ": " 北京 ",
  " 单位 ": " 猫厂 ",
  " 爱好 ": " 写代码，旅游，马拉松 ",
  " 语言 ": "Java、C++、PHP",
  " 自我介绍 ": " 技术专家，简单，为人热情 "
 }
全文搜索引擎能够基于 JSON 文档建立全文索引，然后快速进行全文搜索。以 Elasticsearch 为例，其索引基本原理如下：

Elastcisearch 是分布式的文档存储方式。它能存储和检索复杂的数据结构——序列化成为 JSON 文档——以实时的方式。

在 Elasticsearch 中，每个字段的所有数据都是默认被索引的。即每个字段都有为了快速检索设置的专用倒排索引。而且，不像其他多数的数据库，它能在相同的查询中使用所有倒排索引，并以惊人的速度返回结果。
