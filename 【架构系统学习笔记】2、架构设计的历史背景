目录：
1、机器语言
2、汇编语言
3、高级语言
4、第一次软件危机和结构化程序设计
5、第二次软件危机与面向对象
6、软件架构的历史背景


1、机器语言（1940年之前）

    最早的软件开发使用的是“机器语言”，直接使用二进制码0和1来表示机器可以识别的指令和数据。
机器语言的主要问题是：太难写、太难读、太难改。

2、汇编语言（20世纪40年代）

    为了解决机器语言编写、阅读、修改复杂的问题，汇编语言应运而生。汇编语言又叫“符号语言”，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。
    汇编语言虽然解决了机器语言读写复杂的问题，但本质上还是面向机器的，应为写汇编语言需要我们精读了解计算机底层的知识。除了编写本身复杂，还有另一个复杂的地方在于:不同CPU的汇编指令和结构是不同的。

3、高级语言（20世纪50年代）

    为了解决汇编语言的问题，计算机前辈们从20世纪50年代开始有设计了多个高级语言。最初的高级语言有下面几个，并且这些语言至今还在特定的领域继续使用。
    Fortran：1955年，名称取自“FORmula TRANslator” ，即公式翻译器，由约翰.巴科斯等人发明。
    LISP：1958年，名称取自“LISt Processor”,即枚举处理器，由约翰.麦卡锡等人发明。
    Cobol：1959年，名称取自“Common Business Criented Language”,即通用商业导向语言，由葛丽丝.霍普发明。
    这些语言之所以称之为为高级语言，是因为这些语言让程序员不需要关注机器底层的低级结构和逻辑，而只要关注具体的问题和业务即可。
    通过编译程序的处理，高级语言可以被编译为适合不同CPU指令的机器语言。程序员只要一次程序，就可以在多个不同的机器上编译运行，无须根据不同的机器指令重写程序。

4、第一次软件危机和结构化程序设计（20世纪60年代-20世纪70年代）

    软件规模和复杂度的大大增加，20世纪60年代中期开始爆发了第一次软件危机，典型表现软件质量低下、项目无法如期完成、项目严重超支等，因为软件而导致的重大事故时有发生。
    艾兹赫尔.戴克斯特拉于1968年发表了著名的《GOTO有害论》论文，引起了长达数年的论战，并由此产生了结构化程序设计方法。第一个结构化的程序语言Pascal也在此时诞生，并迅速流行起来。
    结构化程序设计的主要特点是抛弃goto语句，采取“自顶向下，逐步细化、模块化”的指导思想。结构化程序设计本质上还是一种面向过程的设计思想，但通过“自顶向下、逐步细化、模块化”的方法，将软件的复杂度控制在一定范围内，从而从整体上降低了软件开发的复杂度。
    结构化程序方法成为了20世纪70年代软件开发的潮流。

5、第二次软件危机与面向对象（20世纪80年代）
    
    随着硬件的快速发展，业务雪球越来越复杂，以及变成应用领域越来越广泛，第二次软件危机很快就到来。第二次软件危机的根本原因是在于软件生产力远远跟不上硬件和业务的发展。第一次软件危机的根源在于软件的“逻辑”变得非常复杂，而第二次软件危机主要体现在软件的“扩展”变得非常复杂。
    面向对象的思想并不是在第二次软件危机后才出现的，早在1967年的simula语言中就开始提出来了，但第二次软件危机促进了面向对象的发展。
    面向对象真正开始流行是在20世纪80年代，主要得益于C++的功劳，后来的Java、C#把面向对象推向了新的高峰。到现在为止面向对象已经成为了主流的开发思想。

6、软件架构的历史背景

    软件架构真正流行却是从20世纪90年代开始的，由于Rational和Microsoft内部的相关活动，软件架构的概念开始越来与流行。“软件架构”出现的背景并不是整个行业都面临相同的问题，“软件机构”也不是为了解决新的软件危机而产生。
    卡内基.梅隆大学的玛丽.肖和戴维.加兰对软件架构做了很多研究，他们在1994年的一篇文章《软件架构介绍》中写道：
“When systems are constructed from many components,the organization of the overall system—the software architecture-presents a new set of design problems.”
随着软件系统规模的增加，计算机相关算法和数据结构不再构成主要的设计问题；当系统由许多部分组成时，整个系统的组织，也就是所说的“软件架构”，导致了一系列新的设计问题。
    大公司开发的软件系统才具备较大规模，而只有规模较大的软件系统才会面临软件架构相关的问题，例如：
（1）系统规模庞大，内部耦合严重，开发效率低；
（2）系统耦合严重，牵一发动全身，后续修改和扩展困难；
（3）系统逻辑复杂，容易出问题，出问题后很难排查和修复。
软件架构出现是历史必然性。
