复杂度的来源：高性能、高可用、可扩展性、低成本、安全和规模

1、复杂度来源：高性能
（1）软件系统中高性能带来的复杂度主要体现在两个方面：
        1）单台计算机内部为了高性能到来的复杂度
        2）多台计算机集群为了高性能带来的复杂度
（2）单机复杂度
        1）操作系统是软件系统的运行环境，操作系统的复杂度直接决定了软件系统的复杂度。
        2）操作系统和性能最相关的就是进程和线程。
        3） 问题1：如果两个任务运行过程中不能通信，智能是A任务将结果写到存储，B任务再从存储读取进行处理，不仅效率低，而且任务设计更加复杂。
            解决方案：进程间通信的各种方式被设计出来了，包括管道、消息队列、信号量、共享存储等。
        4）问题2：多进程让多任务能够并行处理任务，但本身还是有缺点，单个进程内部只能串行处理，而实际上很多进程内部的子任务并不要求是严格按照时间顺序来执行的，也需要并行处理。
            解决方案：线程是进程内部的子任务，但这些子任务都共享同一份进程数据。为了保证数据的正确性，发明了互斥锁机制。有了多线程之后，操作系统调度的最小单位就变成了线程，而进程变成操作系统分配资源的最小的单位。
        5）问题3：多进程多线程本质上海市分时系统，并不能做到真正的并行。
            解决方案：让多个CPU能够同时执行计算任务，从而实现真正意义上的多任务执行。
                        $ SMP(symmetric multi-processor 对称多处理结构)
                        $ NUMA(non-uniform memory access 非一致存储访问结构)
                        $ MPP(massive parallel processing,海量并行处理结构)
            目前流行的多核处理器就是SMP方案。
        6）要完成一个高性能的软件系统，需要考虑如多进程、多线程、进程间通信、多线程并发等技术点。
            技术并不是最新的就是最好的，也不是非此即彼的选择。
        7）在做架构设计的时候，需要花费很大的精力来结合业务进行分析、判断、选择、组合，这个过程同样很复杂。
            Nginx采用多线程；Redis采用的是单进程；memcache采用的多线程，这些系统都实现了高性能，但内部实现差异却很大。
（3）集群的复杂度
        1）任务分配：指每台机器都可以处理完整的业务任务，不同的任务分配道不同的机器上执行。
            1台服务器演变为两台服务器带来的复杂性，主要体现在：
                    $ 需要增加一个任务分配器，这个分配器可能是硬件网络设备(如F5、交换机等），可能是软件网络设备（如LVS），也可能是负载均衡软件（如Nginx、HAProxy），还可能是自己开发的系统。需要综合考虑性能、成本、可维护性、可用性等各方面的因素。
                    $任务分配器和真正的业务服务器之间有连接和交互，需要选择合适的连接方式，并且对连接进行管理。例如：链接建立、连接检测、连接中断后如何处理等
                    $ 任务分配器需要增加分配算法。例如是采用轮询算法、还是权重分配、又或者按照负载进行分配。
            
            任务分配器扩展为多台机器，复杂度体现在：
                    $ 任务分配器从台变成多台，这个变化带来的复杂度就是需要将不同的用户分配到不同的任务分配器上，常见的方法包括：DNS轮询、智能DNS、CDN（content delivery Network,内容分发网络）、GSLB设备（Global server load balance,全局负载均衡）等
                    $ 任务分配器和业务服务器的链接从简单的1对多变成了多对多的网状结构
                    $ 机器数量聪台扩展到30台（任务分配器比业务服务器少），状态管理、故障处理复杂度也大大增加。
        以业务处理为例，实际上“任务”涵盖的范围很广，可以值完整的业务处理，也可以单指某个具体的任务。例如“存储”、“运算”、“缓存”等都可以作为一项任务，因此存储系统、运算系统、缓存系统都可以按照任务分配的方式来搭建架构。
        此外，“任务分配器”并不一定只能是物理上存在的机器或者一个独立的运行程序，也可以是嵌入在其他程序中的算法，例如memcache的集群架构。
        2）任务分解：通过任务分解的范式，能够把原来大一统但复杂的业务系统，拆分成效而简单但需要多个系统配合的业务系统。
            为何通过任务分解就能够提升性能？
                    $ 简单的系统更加容易做到高性能
                    $ 可以针对单任务进行扩展


2、复杂度来源：高可用
    （1）高可用：系统中无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。
    （2）本质上都是通过“冗余”来实现高可用。单纯从形式上来看，都是通过增加更多机器来达到目的，但本质上是有根本区别的。
    （3）根本区别：高性能增加机器目的在于扩展处理性能；高可用增加机器目的在于冗余处理单元。
    （4）计算高可用：
            “计算”指的是业务的逻辑处理。计算的一个特点就是无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是不一样的。
            双机架构图，复杂度体现在：
                $ 需要增加一个任务分配器，选择合适的任务分配器也是一件复杂的事情，需要综合考虑性能、成本、可维护性、可用性等各方面因素。
                $ 任务分配器和真正的业务服务器之间连接和交互，需要选择合适的连接方式，并且对连接进行管理。例如：链接建立、连接检测、连接中断后如何处理等
                $ 任务分配器增加分配算法。如常见的双机算法有主备、主主、主备方案又可以细分为冷备、温备、热备。

            高可用集群架构，复杂度体现在：
                $ 分配算法：1主3备、2主2备、3主1备、4主0备，具体采用哪种方式，需要结合实际业务需求来分析和判断，并不存在某种算法就一定优于另外的算法。例如zookeeper采用的就是1主多备，而memcached采用的就是全主0备。
（5）存储高可用
        对于需要存储数据的系统来说，整个系统的高可用设计关键点和难点就在于“存储高可用”。
        数据+逻辑=业务
        存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响。
（6）高可用状态决策
        无论是计算高可用海曙存储高可用，其基础都是“状态决策”，即系统需要能够判断当前状态是正常还是一场，如果出现了异常就要采取行动来保证高可用。
        本质的矛盾：通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确。
        1）独裁式：指存在一个独立的决策主体，称其为“决策者”，负责收集信息然后进行决策；所有冗余的个体，称为“上报者”，都将状态发送给决策者。
        2）协商式：指两个独立的个体通过交流信息，然后根据规则进行决策，最常用的协商式决策就是主备决策。
        3）民主式：指多个独立的个体通过投票的方式来进行状态决策。

3、复杂度来源：可扩展性
设计具备良好可扩展性的系统，有两个基本条件：正确预测变化、完美封装变化。
（1）预测变化
    软件系统在发布后还可以不断地修改和演进，这就意味着不断有新的需求需要实现。
    综合分析，预测变化的复杂性在于：
    1）不能每个设计点都考虑可扩展性
    2）不能完全不考虑可扩展性
    3）所有的预测都存在出错的可能性
        对于架构师来说，如何把握预测的程度和提升预测结果的准确性，是一件很复杂的事情，而且没有通用的标准可以简单套上去，更多是靠自己的经验、直觉。

（2）应对变化
    应对变化的常见方案：
        将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”。无论是变化层依赖稳定层，还是稳定层依赖变化层都是可以，需要根据具体业务情况来设计。
        通过剥离变化层和稳定层的方式应对变化都会带来两个主要的复杂性的相关问题。
        1）系统需要拆分出变化层和稳定层
        2）需要设计变化层和稳定层之间的接口
        
        第二种常见的应对变化的方案：提炼出“抽象层”和一个“实现层”。

4、复杂度来源：低成本
     架构方案只涉及几台或者十几台服务器时，一般情况下成本并不是我们重点关注的目标，但如果架构方案设计几百上千甚至上万台服务器，成本就会变成一个非常重要的架构。
5、复杂度来源：安全(设计者常常忽略这个)
6、复杂度来源：规模
