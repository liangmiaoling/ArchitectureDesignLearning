计算高可用的主要设计目标是当出现部分硬件损坏是，计算任务能够继续正常运行。
设计思想：通过增加跟多服务器来达到计算高可用。
设计复杂度：主要体现在任务管理方面，即当任务在某台服务器上执行失败后，如何将任务重新分配到新的服务器进行执行。

计算高可用架构设计的关键点：
1、哪些服务器可以执行任务。
    （1）第一种方式：每个服务器都可以执行任务。
    （2）第二种方式：只有特定服务器（通常叫“主机”）可以执行任务。当执行任务的服务器故障后，系统需要挑选新的服务器来执行任务。
2、任务如何重新执行。
    （1）第一种策略：对于已经分配的任务即使执行失败也不做任何处理，系统只要保证新的任务能够分配到其他非故障服务器上执行即可。
    （2）第二种策略：设计一个任务管理器来管理需要执行的计算任务，服务器执行完任务后，需要项任务管理器反馈任务执行结果，任务管理器根据任务执行结果来决定是否需要将任务重新分配到另外的服务其实执行。
注意：任务分配器是一个逻辑的概念，并不一定要求系统存在一个独立的任务分配器模块。

常见的计算高可用架构：主备、主从和集群。

一、主备
主备架构是计算高可用最简单的架构，和存储高科应的主备架构类似。计算高可用的主备架构无需数据复制，其架构逻辑关系如下：
任务分配器->主机（->：计算任务）
任务分配器 - ->备机（- - >:计算任务（人工切换））
主备方案详细设计：
（1）主机执行所有计算任务。
（2）当主机故障时，任务分配器不会自动将计算机任务发送给备机，此时系统处于不可用状态。
（3）如果主机能够恢复（自动恢复），任务分配器继续将任务发送给主机。
（4）如果主机不能够恢复，则需要人工操作，将备机升为主机，然后让人物分配器将任务发送给新的主机；同时为了继续保持主备架构，需要人工增加新的机器作为备机。
主备架构又可以细分为冷备份架构、温备份架构。
（1）冷备
（2）温备：备机上的业务系统已经启动，只是不对外提供服务，主机故障后，人工只需要将任务分配的任务请求切换发送到备机即可。

计算高可用的主备架构也比较适合与内部管理系统、后台管理系统这类使用人数不多、使用频率不高的业务，不太适合在线的业务。

二、主从
任务分配器需要将任务进行分类，确定哪些任务可以发送给主机执行，哪些任务可以发送给备机执行。其架构的逻辑关系如下：
任务分配器->主机（->：计算任务A）
任务分配器 ->备机（->:计算任务B）
主从方案详细设计：
（1）正常情况下，主机执行部分计算任务，备机执行部分计算任务。
（2）当主机故障时，任务分配器不会自动将原来发送给主机的任务发送给从机，而是继续发送给主机，不管这些任务执行是否成功。
（3）如果主机修复，任务分配器继续按照原有的设计策略分配任务，即计算任务A发送给主机，计算任务B发送给从机。
（4）如果主机不能够恢复，则需要人工操作，将原来的从机升级为主机，增加新的机器作为从机，新的从机准备就绪后，任务分配继续按照原有的设计策略分配任务。

三、集群
高可用计算的集群方案根据急群众服务器节点角色不同，可以分为两类：一类是对称集群。另一类是非对称集群。
需要注意的是，计算高可用集群包含2台服务器的器群。

1、对称集群
即负载均衡集群。
负载均衡集群详细设计：
（1）正常情况下，任务分配器采取某种策略将计算任务分配给集群中的不同服务器。
（2）当集群中的某台服务器故障后，任务分配器不在将任务分配给它，而是将任务分配给其他服务器执行。
（3）当故障的服务器恢复后，任务分配器重新将任务分配给它执行。
负载均衡集群的设计关键点在于：
1）任务分配器需要选取分配策略。
2）任务分配器需要检测服务器状态。

2、非对称集群
非对称集群中不同服务器的角色是不同的，不同角色的服务器承担不同的职责。
非对称集群架构详细设计：
（1）集群会通过某种方式来区分不同服务器的角色。
（2）任务分配器将不同任务发送给不同服务器。
（3）当指定类型的服务器故障时，需要重新分配角色。
设计复杂度主要体现：
（1）任务分配策略更加复杂：需要将任务划分为不同类型并分配给不同角色的集群节点。
（2）角色分配策略实现比较复杂。

以zookeeper为例：
（1）任务分配器：zookeeper中不存在独立的任务分配节点，每个server都是任务分配器，follower收到请求后会进行判断，如果是写请求就转发给leader，如果是读请求就自己处理。
（2）角色指定：zookeeper通过ZAB算法来选举leader。


计算高可用架构，主要解决当单点发生故障后，原本发送到故障点的任务，任务如何分发给非故障点，根据业务特点选择分发和重试机制即可，不存在数据一致性问题，只需要保证任务计算完成即可存储高可用架构，解决的问题是当单点发生故障了，任务如何分发给其他非故障节点，以及如何保障数据的一致问题。
所以存储的高可用比计算的高可用的设计更为复杂。






